Here's what I recommend sending to the Replit agent:

---

## IMPLEMENTATION DIRECTIVE: Governance Enforcement Enhancement

Based on our audit findings and analysis, please implement the following changes. We're proceeding with **Option A** (update code to match documentation).

### Implementation Order

**Phase 1: Create Governance Enforcement Service + Gate 1 Enhancement**

#### Step 1.1: Create New Service File
Create `server/services/governance-enforcement.ts` with the following structure:

```typescript
/**
 * Governance Enforcement Service
 * 
 * Centralizes all governance gate logic, activation blocking,
 * auto-deactivation, and phase transition enforcement.
 * 
 * Industry Standards Alignment:
 * - NIST AI RMF (GOVERN function)
 * - ISO 42001 (AI lifecycle management)
 * - NAIC Model Bulletin (insurance governance)
 */

import { UseCase } from '../../shared/schema';
import { calculateGovernanceStatus, checkGate1, checkGate2, checkGate3 } from '../../shared/calculations';
import { deriveTomPhase, getPhaseExitRequirements } from '../../shared/tom';

// Types
export interface GateResult {
  passed: boolean;
  issues: string[];
}

export interface GovernanceCheckResult {
  canActivate: boolean;
  governanceStatus: 'complete' | 'incomplete' | 'blocked';
  gates: {
    operatingModel: GateResult;
    intake: GateResult;
    responsibleAI: GateResult;
  };
  missingFields: string[];
}

export interface PhaseTransitionResult {
  allowed: boolean;
  requiresJustification: boolean;
  currentPhase: string;
  targetPhase: string;
  pendingExitRequirements: string[];
}

export interface ActivationBlockResult {
  blocked: boolean;
  reason?: string;
  governanceCheck?: GovernanceCheckResult;
}

// Constants
const ACTIVATION_STATUSES = ['In-flight', 'Implemented'];
const BYPASS_STATUSES = ['Discovery', 'Backlog', 'On Hold'];

/**
 * Check if a use case can be activated (moved to an active status)
 */
export function checkActivationAllowed(
  useCase: UseCase,
  targetStatus: string
): ActivationBlockResult {
  // Only enforce for activation statuses
  if (!ACTIVATION_STATUSES.includes(targetStatus)) {
    return { blocked: false };
  }

  const governanceCheck = performFullGovernanceCheck(useCase);

  if (!governanceCheck.canActivate) {
    return {
      blocked: true,
      reason: 'GOVERNANCE_INCOMPLETE',
      governanceCheck
    };
  }

  return { blocked: false };
}

/**
 * Check if updates would cause governance regression and require auto-deactivation
 */
export function checkGovernanceRegression(
  currentUseCase: UseCase,
  updatedFields: Partial<UseCase>
): { shouldDeactivate: boolean; reason?: string; regressedGate?: string } {
  // Only check if currently in an active status
  if (!ACTIVATION_STATUSES.includes(currentUseCase.useCaseStatus)) {
    return { shouldDeactivate: false };
  }

  // Merge current with updates
  const merged = { ...currentUseCase, ...updatedFields } as UseCase;

  // Check if governance would still pass
  const currentGovernance = performFullGovernanceCheck(currentUseCase);
  const newGovernance = performFullGovernanceCheck(merged);

  if (currentGovernance.canActivate && !newGovernance.canActivate) {
    // Identify which gate regressed
    const regressedGate = identifyRegressedGate(currentGovernance, newGovernance);
    
    return {
      shouldDeactivate: true,
      reason: `Governance regression detected: ${regressedGate} gate no longer passes`,
      regressedGate
    };
  }

  return { shouldDeactivate: false };
}

/**
 * Check phase transition requirements
 */
export function checkPhaseTransition(
  useCase: UseCase,
  targetStatus: string,
  justification?: string
): PhaseTransitionResult {
  const currentPhase = deriveTomPhase(useCase);
  const targetPhase = deriveTomPhase({ ...useCase, useCaseStatus: targetStatus } as UseCase);

  // No phase change
  if (currentPhase === targetPhase) {
    return {
      allowed: true,
      requiresJustification: false,
      currentPhase,
      targetPhase,
      pendingExitRequirements: []
    };
  }

  // Bypass check for unphased/disabled states
  if (currentPhase === 'Unphased' || currentPhase === 'Disabled') {
    return {
      allowed: true,
      requiresJustification: false,
      currentPhase,
      targetPhase,
      pendingExitRequirements: []
    };
  }

  // Check exit requirements
  const exitRequirements = getPhaseExitRequirements(currentPhase);
  const pendingRequirements = checkExitRequirements(useCase, exitRequirements);

  if (pendingRequirements.length > 0 && !justification) {
    return {
      allowed: false,
      requiresJustification: true,
      currentPhase,
      targetPhase,
      pendingExitRequirements: pendingRequirements
    };
  }

  return {
    allowed: true,
    requiresJustification: pendingRequirements.length > 0,
    currentPhase,
    targetPhase,
    pendingExitRequirements: pendingRequirements
  };
}

/**
 * Perform full governance check across all 3 gates
 */
export function performFullGovernanceCheck(useCase: UseCase): GovernanceCheckResult {
  const gate1 = checkGate1Enhanced(useCase);
  const gate2 = gate1.passed ? checkGate2(useCase) : { passed: false, issues: ['Gate 1 must pass first'] };
  const gate3 = gate2.passed ? checkGate3(useCase) : { passed: false, issues: ['Gate 2 must pass first'] };

  const allIssues = [...gate1.issues, ...gate2.issues, ...gate3.issues];

  return {
    canActivate: gate1.passed && gate2.passed && gate3.passed,
    governanceStatus: gate3.passed ? 'complete' : 'incomplete',
    gates: {
      operatingModel: gate1,
      intake: gate2,
      responsibleAI: gate3
    },
    missingFields: allIssues
  };
}

/**
 * Enhanced Gate 1 check with all 3 requirements
 * (Replaces the single-field check in calculations.ts)
 */
function checkGate1Enhanced(useCase: UseCase): GateResult {
  const issues: string[] = [];

  // Requirement 1: Primary Business Owner
  if (!useCase.primaryBusinessOwner || useCase.primaryBusinessOwner.trim() === '') {
    issues.push('Primary Business Owner is required');
  }

  // Requirement 2: Status beyond Discovery
  if (useCase.useCaseStatus === 'Discovery') {
    issues.push('Use case must progress beyond Discovery status');
  }

  // Requirement 3: Business Function assigned
  if (!useCase.businessFunction || useCase.businessFunction.trim() === '') {
    issues.push('Business Function is required');
  }

  return {
    passed: issues.length === 0,
    issues
  };
}

// Helper functions
function identifyRegressedGate(
  before: GovernanceCheckResult,
  after: GovernanceCheckResult
): string {
  if (before.gates.operatingModel.passed && !after.gates.operatingModel.passed) {
    return 'Operating Model';
  }
  if (before.gates.intake.passed && !after.gates.intake.passed) {
    return 'Intake & Prioritization';
  }
  if (before.gates.responsibleAI.passed && !after.gates.responsibleAI.passed) {
    return 'Responsible AI';
  }
  return 'Unknown';
}

function checkExitRequirements(useCase: UseCase, requirements: string[]): string[] {
  // Implementation depends on your phase exit requirement definitions
  // Return list of requirements not yet met
  const pending: string[] = [];
  
  // Example checks based on typical phase requirements
  for (const req of requirements) {
    if (req === 'scoring_complete' && !hasCompleteScoring(useCase)) {
      pending.push('Complete all 10 scoring levers');
    }
    if (req === 'rai_complete' && !hasCompleteRAI(useCase)) {
      pending.push('Complete Responsible AI assessment');
    }
    // Add more requirement checks as needed
  }
  
  return pending;
}

function hasCompleteScoring(useCase: UseCase): boolean {
  const levers = [
    useCase.revenueImpact, useCase.costSavings, useCase.riskReduction,
    useCase.brokerPartnerExperience, useCase.strategicFit,
    useCase.dataReadiness, useCase.technicalComplexity, useCase.changeImpact,
    useCase.modelRisk, useCase.adoptionReadiness
  ];
  return levers.every(l => l && l >= 1 && l <= 5);
}

function hasCompleteRAI(useCase: UseCase): boolean {
  return !!(
    useCase.explainabilityRequired !== undefined &&
    useCase.customerHarmRisk &&
    useCase.humanAccountability !== undefined &&
    useCase.dataOutsideUkEu !== undefined &&
    useCase.thirdPartyModel !== undefined
  );
}
```

#### Step 1.2: Update Gate 1 in calculations.ts
In `shared/calculations.ts` (Lines 746-781), update the `checkOperatingModelGate` function to match the enhanced version above. Alternatively, have the existing function call the new service for consistency.

#### Step 1.3: Integrate Service into Routes
In `server/routes.ts`, import and use the governance enforcement service:

```typescript
import {
  checkActivationAllowed,
  checkGovernanceRegression,
  checkPhaseTransition,
  performFullGovernanceCheck
} from './services/governance-enforcement';

// In PUT /api/use-cases/:id endpoint
app.put('/api/use-cases/:id', async (req, res) => {
  try {
    const useCase = await storage.getUseCase(req.params.id);
    if (!useCase) {
      return res.status(404).json({ error: 'Use case not found' });
    }

    const updates = req.body;

    // 1. Check activation blocking (if status changing to active)
    if (updates.useCaseStatus && updates.useCaseStatus !== useCase.useCaseStatus) {
      const activationCheck = checkActivationAllowed(useCase, updates.useCaseStatus);
      
      if (activationCheck.blocked) {
        return res.status(403).json({
          error: activationCheck.reason,
          message: 'Use case cannot be activated until all governance gates pass',
          ...activationCheck.governanceCheck
        });
      }

      // 2. Check phase transition requirements
      const phaseCheck = checkPhaseTransition(
        useCase,
        updates.useCaseStatus,
        updates.phaseTransitionJustification
      );

      if (!phaseCheck.allowed) {
        return res.status(400).json({
          error: 'PHASE_TRANSITION_REQUIRES_JUSTIFICATION',
          ...phaseCheck,
          message: 'Provide phaseTransitionJustification to proceed with incomplete exit requirements'
        });
      }

      // Store justification if provided
      if (phaseCheck.requiresJustification && updates.phaseTransitionJustification) {
        updates.lastPhaseTransitionReason = updates.phaseTransitionJustification;
        updates.lastPhaseTransitionAt = new Date().toISOString();
      }
    }

    // 3. Check for governance regression
    const regressionCheck = checkGovernanceRegression(useCase, updates);
    
    if (regressionCheck.shouldDeactivate) {
      // Force deactivation
      updates.useCaseStatus = 'Backlog';
      
      // Log the auto-deactivation
      await storage.createGovernanceAuditLog({
        useCaseId: useCase.id,
        action: 'AUTO_DEACTIVATION',
        reason: regressionCheck.reason,
        previousStatus: useCase.useCaseStatus,
        newStatus: 'Backlog',
        regressedGate: regressionCheck.regressedGate,
        timestamp: new Date().toISOString(),
        userId: req.session?.userId || 'system'
      });
    }

    // Proceed with update
    const updatedUseCase = await storage.updateUseCase(req.params.id, updates);
    
    return res.json(updatedUseCase);
    
  } catch (error) {
    console.error('Error updating use case:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});
```

#### Step 1.4: Add Governance Audit Log Function
If not already present in `server/storage.ts`, add:

```typescript
async createGovernanceAuditLog(entry: {
  useCaseId: number;
  action: 'AUTO_DEACTIVATION' | 'ACTIVATION_BLOCKED' | 'PHASE_TRANSITION_OVERRIDE';
  reason: string;
  previousStatus?: string;
  newStatus?: string;
  regressedGate?: string;
  timestamp: string;
  userId: string;
}): Promise<void> {
  await db.insert(governanceAuditLog).values(entry);
}
```

---

### Phase 2: Testing

Create `server/services/__tests__/governance-enforcement.test.ts`:

```typescript
import {
  checkActivationAllowed,
  checkGovernanceRegression,
  checkPhaseTransition,
  performFullGovernanceCheck
} from '../governance-enforcement';

describe('Governance Enforcement Service', () => {
  describe('Gate 1 - Operating Model', () => {
    it('should fail when primaryBusinessOwner is empty', () => {
      const useCase = { primaryBusinessOwner: '', useCaseStatus: 'Backlog', businessFunction: 'Claims' };
      const result = performFullGovernanceCheck(useCase as any);
      expect(result.gates.operatingModel.passed).toBe(false);
      expect(result.gates.operatingModel.issues).toContain('Primary Business Owner is required');
    });

    it('should fail when status is Discovery', () => {
      const useCase = { primaryBusinessOwner: 'John Doe', useCaseStatus: 'Discovery', businessFunction: 'Claims' };
      const result = performFullGovernanceCheck(useCase as any);
      expect(result.gates.operatingModel.passed).toBe(false);
      expect(result.gates.operatingModel.issues).toContain('Use case must progress beyond Discovery status');
    });

    it('should fail when businessFunction is empty', () => {
      const useCase = { primaryBusinessOwner: 'John Doe', useCaseStatus: 'Backlog', businessFunction: '' };
      const result = performFullGovernanceCheck(useCase as any);
      expect(result.gates.operatingModel.passed).toBe(false);
      expect(result.gates.operatingModel.issues).toContain('Business Function is required');
    });

    it('should pass when all 3 requirements met', () => {
      const useCase = { primaryBusinessOwner: 'John Doe', useCaseStatus: 'Backlog', businessFunction: 'Claims' };
      const result = performFullGovernanceCheck(useCase as any);
      expect(result.gates.operatingModel.passed).toBe(true);
    });
  });

  describe('Activation Blocking', () => {
    it('should block activation when governance incomplete', () => {
      const useCase = { primaryBusinessOwner: '', useCaseStatus: 'Backlog' };
      const result = checkActivationAllowed(useCase as any, 'In-flight');
      expect(result.blocked).toBe(true);
      expect(result.reason).toBe('GOVERNANCE_INCOMPLETE');
    });

    it('should allow non-activation status changes', () => {
      const useCase = { primaryBusinessOwner: '' };
      const result = checkActivationAllowed(useCase as any, 'On Hold');
      expect(result.blocked).toBe(false);
    });
  });

  describe('Governance Regression', () => {
    it('should trigger deactivation when owner removed from active use case', () => {
      const current = {
        primaryBusinessOwner: 'John Doe',
        useCaseStatus: 'In-flight',
        businessFunction: 'Claims',
        // ... complete governance fields
      };
      const updates = { primaryBusinessOwner: '' };
      
      const result = checkGovernanceRegression(current as any, updates);
      expect(result.shouldDeactivate).toBe(true);
      expect(result.regressedGate).toBe('Operating Model');
    });
  });
});
```

---

### Deliverables Checklist

Please confirm completion of each:

- [ ] Created `server/services/governance-enforcement.ts`
- [ ] Updated Gate 1 in `shared/calculations.ts` to check all 3 requirements
- [ ] Integrated activation blocking in `PUT /api/use-cases/:id`
- [ ] Integrated governance regression check with auto-deactivation
- [ ] Integrated phase transition justification requirement
- [ ] Added `createGovernanceAuditLog` function to storage
- [ ] Created test file with passing tests
- [ ] Verified existing 126 use cases don't break (run migration check)

### Data Migration Note

Before deploying, run this query to identify use cases that would fail the new Gate 1:

```sql
SELECT id, title, primary_business_owner, use_case_status, business_function
FROM use_cases
WHERE use_case_status IN ('In-flight', 'Implemented')
AND (
  primary_business_owner IS NULL OR primary_business_owner = ''
  OR use_case_status = 'Discovery'
  OR business_function IS NULL OR business_function = ''
);
```

If any results, we'll need to either update those use cases or add a migration grace period.

---

Let me know once this is implemented and I'll review the changes.