The Replit agent's analysis is spot-on. These are legitimate architectural gaps. Here's my response:

My Assessment: Agent is Correct
IssueAgent's CallMy VerdictSteady State ambiguityMake it manual-only✅ Agree - no other clean way to distinguishOn Hold unmappedMap to Foundation or add 5th phase✅ Agree - map to Foundation (paused work returns to backlog)Sparse deployment dataMake optional/tiebreaker✅ Agree - critical fix, data shows most are NULLConflict resolutionStatus-first, deployment-tiebreaker✅ Agree - needs explicit rulePhase historyAdd phaseEnteredAt✅ Agree - needed for Phase 2 Value Realization

Revised Prompt for Phase 1
Give this to the agent:
PHASE 1 REVISED: TOM CONFIGURATOR - INCORPORATING EDGE CASE FIXES

Your analysis was correct. Here are the approved adjustments:

=== APPROVED CHANGES TO ORIGINAL SPEC ===

1. STEADY STATE = MANUAL ONLY
   - Steady State phase has "manualOnly": true
   - It is NEVER auto-derived from status/deployment
   - Requires explicit promotion via tomPhaseOverride field
   - This solves the Transition vs Steady State ambiguity

2. ON HOLD MAPPING
   - Map "On Hold" to Foundation phase
   - Rationale: Paused work returns to backlog when resumed
   - mappedStatuses for Foundation: ["Discovery", "Backlog", "On Hold"]

3. DEPLOYMENT STATUS = OPTIONAL TIEBREAKER
   - Phase derivation logic:
     Step 1: Match by useCaseStatus (required)
     Step 2: If multiple phases match same status, use deploymentStatus as tiebreaker
     Step 3: If deploymentStatus is NULL or still ambiguous, use lowest priority number
   - This handles the 125+ use cases with NULL deployment

4. ADD MINIMAL FIELDS TO use_cases TABLE
   - tomPhaseOverride (text, nullable): Manual phase assignment for edge cases (especially Steady State)
   - phaseEnteredAt (timestamp, nullable): Auto-updated when derived phase changes
   - overrideReason (text, nullable): Why manual override was applied
   
   These are the ONLY new fields on use_cases. Phase is still DERIVED unless overridden.

5. EXPLICIT PRIORITY-BASED MATCHING
   Each phase gets a priority number. Lower = matched first when ambiguous.

=== REVISED PHASE CONFIGURATION ===

{
  "enabled": "false",
  "activePreset": "coe_led",
  "presets": {
    "centralized": { "name": "Centralized CoE", "description": "Single AI team owns all delivery" },
    "federated": { "name": "Federated Model", "description": "Business units own AI with central standards" },
    "hybrid": { "name": "Hybrid Model", "description": "Central platform, distributed execution" },
    "coe_led": { "name": "CoE-Led with Business Pods", "description": "CoE leads with embedded business pods" }
  },
  "phases": [
    {
      "id": "foundation",
      "name": "Foundation",
      "description": "Initial setup, governance alignment, and backlog grooming",
      "order": 1,
      "priority": 1,
      "color": "#3C2CDA",
      "mappedStatuses": ["Discovery", "Backlog", "On Hold"],
      "mappedDeployments": [],
      "manualOnly": false,
      "governanceGate": "ai_steerco",
      "expectedDurationWeeks": 8
    },
    {
      "id": "strategic",
      "name": "Strategic",
      "description": "Active development, pilots, and value validation",
      "order": 2,
      "priority": 2,
      "color": "#1D86FF",
      "mappedStatuses": ["In-flight"],
      "mappedDeployments": ["PoC", "Pilot"],
      "manualOnly": false,
      "governanceGate": "working_group",
      "expectedDurationWeeks": 16
    },
    {
      "id": "transition",
      "name": "Transition",
      "description": "Production deployment and capability transfer in progress",
      "order": 3,
      "priority": 3,
      "color": "#14CBDE",
      "mappedStatuses": ["Implemented"],
      "mappedDeployments": ["Production"],
      "manualOnly": false,
      "governanceGate": "business_owner",
      "expectedDurationWeeks": 12
    },
    {
      "id": "steady_state",
      "name": "Steady State",
      "description": "Full client ownership, optimization mode",
      "order": 4,
      "priority": 4,
      "color": "#07125E",
      "mappedStatuses": [],
      "mappedDeployments": [],
      "manualOnly": true,
      "governanceGate": "none",
      "expectedDurationWeeks": null
    }
  ],
  "governanceBodies": [
    {
      "id": "ai_steerco",
      "name": "AI Steering Committee",
      "role": "Strategic oversight and investment decisions",
      "cadence": "Monthly"
    },
    {
      "id": "working_group",
      "name": "AI Working Group",
      "role": "Tactical execution and prioritization",
      "cadence": "Bi-weekly"
    },
    {
      "id": "business_owner",
      "name": "Business Owner Review",
      "role": "Value validation and adoption sign-off",
      "cadence": "Weekly"
    }
  ],
  "derivationRules": {
    "matchOrder": ["useCaseStatus", "deploymentStatus"],
    "fallbackBehavior": "lowestPriority",
    "nullDeploymentHandling": "ignoreInMatching"
  }
}

=== PHASE DERIVATION ALGORITHM ===

function derivePhase(useCase, tomConfig):
  // 1. Check for manual override first
  if useCase.tomPhaseOverride is not null:
    return findPhaseById(useCase.tomPhaseOverride)
  
  // 2. Find matching phases by status
  matchingPhases = []
  for phase in tomConfig.phases:
    if phase.manualOnly:
      continue  // Skip manual-only phases
    if useCase.useCaseStatus in phase.mappedStatuses:
      matchingPhases.push(phase)
  
  // 3. If no match, return "unmapped"
  if matchingPhases.length == 0:
    return { id: "unmapped", name: "Unmapped", color: "#gray" }
  
  // 4. If single match, return it
  if matchingPhases.length == 1:
    return matchingPhases[0]
  
  // 5. Multiple matches - use deployment as tiebreaker
  if useCase.deploymentStatus is not null:
    for phase in matchingPhases:
      if useCase.deploymentStatus in phase.mappedDeployments:
        return phase
  
  // 6. Still ambiguous or null deployment - use lowest priority
  return matchingPhases.sort(by: priority)[0]

=== UPDATED SCHEMA CHANGES ===

-- metadata_config (as before)
Add tomConfig JSONB field

-- use_cases (NEW - minimal additions)
ALTER TABLE use_cases ADD COLUMN tom_phase_override TEXT;
ALTER TABLE use_cases ADD COLUMN phase_entered_at TIMESTAMP;
ALTER TABLE use_cases ADD COLUMN tom_override_reason TEXT;

Note: Use camelCase in Drizzle schema per replit.md (tomPhaseOverride, phaseEnteredAt, tomOverrideReason)

=== PHASE HISTORY TRACKING ===

When derived phase changes (detected by comparing previous vs current):
1. Update phaseEnteredAt to current timestamp
2. This happens automatically in the API when use case status/deployment changes
3. Do NOT update phaseEnteredAt if phase stayed the same

This enables Phase 2 (Value Realization) to answer:
- "When did this enter Transition phase?"
- "How long in Strategic phase?"

=== ADMIN UI ADDITIONS ===

In Use Case Edit Form (NOT a new tab, just new fields in existing form):
- Add "TOM Phase Override" dropdown (only shows when TOM enabled)
- Shows: [Auto-derive (default), Foundation, Strategic, Transition, Steady State]
- Add "Override Reason" text field (required if override selected)
- Selecting override clears when set back to "Auto-derive"

=== VALIDATION CRITERIA (UPDATED) ===

□ All 126 use cases derive to a phase (none "unmapped" with current data)
□ "On Hold" use cases map to Foundation
□ NULL deployment status doesn't break derivation
□ Steady State only reachable via manual override
□ phaseEnteredAt updates when phase changes
□ Admin can set/clear override with reason
□ Existing functionality unchanged

=== CHECKPOINT SEQUENCE (UPDATED) ===

1. Schema: tomConfig JSONB + 3 new use_cases fields
2. Derivation: Algorithm implemented server-side
3. API: TOM endpoints + phase derivation on GET /api/use-cases
4. Admin Tab: TOM Configurator functional
5. Override UI: Phase override in use case edit form
6. Dashboard: Phase summary with accurate counts
7. History: phaseEnteredAt updating on phase transitions

Proceed with Step 1 (Schema). Checkpoint after each step.

Summary of Changes from Original
Original SpecRevised SpecNo fields on use_cases3 minimal fields: tomPhaseOverride, phaseEnteredAt, tomOverrideReasonSteady State auto-derivedSteady State manual-onlyOn Hold not mappedOn Hold → FoundationNo conflict resolutionExplicit priority-based algorithmNo phase historyphaseEnteredAt timestampDeployment requiredDeployment optional tiebreaker
The agent caught real issues. This revised approach is more robust and will actually work with your data.